# -*- coding: utf-8 -*-
"""Hybrid CNN-LSTM Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cRRIBGyKRY2UFbHXFBFErOsasP6wxT5r
"""

# Google Colab Notebook for Hybrid CNN-LSTM Occupancy Prediction and Evaluation

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Conv1D, MaxPooling1D, TimeDistributed, Flatten, Input
from tensorflow.keras.optimizers import Adam
# Imports for Evaluation Metrics
from sklearn.metrics import r2_score, mean_squared_error
from math import sqrt
import matplotlib.pyplot as plt

# --- Helper Function for Metrics Calculation ---
def calculate_metrics(y_true, y_pred):
    """Calculates R-squared, MSE, and RMSE."""
    # R-squared (Coefficient of Determination)
    r2 = r2_score(y_true, y_pred)

    # Mean Squared Error (MSE)
    mse = mean_squared_error(y_true, y_pred)

    # Root Mean Squared Error (RMSE)
    rmse = sqrt(mse)

    return r2, mse, rmse

# --- File Paths (Assuming files are in the local working directory) ---
file_names = [
    'Miguel_Pro_cleaned.csv',
    'Gisbert_2nd_Floor_cleaned.csv',
    'American_Corner_cleaned.csv',
    'Gisbert_4th_Floor_cleaned.csv',
    'Gisbert_5th_Floor_cleaned.csv',
    'Gisbert_3rd_Floor_cleaned.csv'
]

# DataFrame to store results for all files
results_df = pd.DataFrame(columns=['Location', 'R2_Score', 'MSE', 'RMSE'])


# --- Configuration for Hybrid Model Input ---
n_steps = 6  # Timesteps per internal sequence (e.g., 6 hours)
n_seq = 4    # Number of sequences (e.g., 4 sequences of 6 hours = 24 total hours)
sequence_length = n_steps * n_seq # Total 24 hours lookback


for file_name in file_names:
    base_file_name = file_name
    location_name = base_file_name.replace('_cleaned.csv', '')

    print(f"\n=======================================================")
    print(f"Processing file: {base_file_name} (Hybrid CNN-LSTM)")
    print(f"=======================================================")

    # --- 1. Load and Preprocess Data ---
    try:
        df = pd.read_csv(file_name)
    except FileNotFoundError:
        print(f"Error: File '{file_name}' not found. Skipping.")
        continue

    df['Start_dt'] = pd.to_datetime(df['Start_dt'])
    df.set_index('Start_dt', inplace=True)
    # Resample to get hourly unique user counts (occupancy)
    occupancy = df['Client MAC'].resample('h').nunique().rename('occupancy').reset_index()
    occupancy.dropna(inplace=True)

    # --- 2. Create Sequences for Time Series Forecasting ---
    data = occupancy['occupancy'].values.reshape(-1, 1)
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_data = scaler.fit_transform(data)

    X, y = [], []
    for i in range(len(scaled_data) - sequence_length):
        X.append(scaled_data[i:i+sequence_length])
        y.append(scaled_data[i+sequence_length])

    X = np.array(X)
    y = np.array(y)

    # Reshape input for Hybrid CNN-LSTM: [samples, n_seq, n_steps, n_features]
    if X.shape[0] < 2:
        print(f"Error: Not enough samples after creating sequences to split for {file_name}. Skipping this file.")
        continue

    X = X.reshape((X.shape[0], n_seq, n_steps, 1))

    # 80/20 Train/Test Split
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)
    print(f"Total sequences: {len(X)}. Training shape: {X_train.shape}, Testing shape: {X_test.shape}")

    # --- 3. Build and Train the Hybrid CNN-LSTM Model ---
    model = Sequential([
        # TimeDistributed applies the Conv1D layer to each of the 'n_seq' sequences
        Input(shape=(n_seq, n_steps, 1)),
        TimeDistributed(Conv1D(filters=64, kernel_size=2, activation='relu')),
        TimeDistributed(MaxPooling1D(pool_size=2)),
        TimeDistributed(Flatten()),
        LSTM(units=50, activation='relu'),
        Dense(25, activation='relu'),
        Dense(1) # Output layer
    ])

    model.compile(optimizer=Adam(learning_rate=0.001), loss='mean_squared_error')

    # Fit the model (Set verbose to 0 for less output during training)
    history = model.fit(X_train, y_train, epochs=50, batch_size=32, validation_split=0.1, verbose=0)

    # --- 4. Evaluate the Model and Calculate Metrics ---

    # Get scaled predictions
    predictions_scaled = model.predict(X_test, verbose=0)

    # Inverse transform to get actual occupancy counts
    predictions = scaler.inverse_transform(predictions_scaled)
    y_test_actual = scaler.inverse_transform(y_test)

    # Flatten arrays for metric calculation (sklearn expects 1D arrays)
    y_true_flat = y_test_actual.flatten()
    y_pred_flat = predictions.flatten()

    # Calculate R2, MSE, RMSE
    r2, mse, rmse = calculate_metrics(y_true_flat, y_pred_flat)

    print(f"\n--- Evaluation Metrics for {location_name} (Hybrid CNN-LSTM) ---")
    print(f"R-squared (R2): {r2:.4f}")
    print(f"Mean Squared Error (MSE): {mse:.2f}")
    print(f"Root Mean Squared Error (RMSE): {rmse:.2f} (In units of 'Number of Users')")

    # Store results
    results_df.loc[len(results_df)] = [location_name, r2, mse, rmse]

    # --- SAVE MODEL AND SCALER ---
    model_save_path = f'/opt/airflow/models/{location_name}_cnn_only.h5'
    scaler_save_path = f'/opt/airflow/models/{location_name}_cnn_only_scaler.pkl'

    try:
        model.save(model_save_path)
        print(f"Model saved to {model_save_path}")
        import pickle
        with open(scaler_save_path, 'wb') as f:
            pickle.dump(scaler, f)
        print(f"Scaler saved to {scaler_save_path}")
    except Exception as e:
        print(f"Error saving model or scaler for {location_name}: {e}")

    # --- 5. Visualize Results ---
    plt.figure(figsize=(15, 6))
    plt.plot(y_test_actual, label='Actual Occupancy', color='blue')
    plt.plot(predictions, label='Predicted Occupancy', color='purple', linestyle='--')
    plt.title(f'Hybrid CNN-LSTM Model: Actual vs. Predicted Occupancy for {location_name}')
    plt.xlabel('Time Step')
    plt.ylabel('Number of Users')
    plt.legend()
    plt.grid(True)
    plt.show()

print("\n\n=======================================================")
print("FINAL MODEL EVALUATION SUMMARY (Hybrid CNN-LSTM)")
print("=======================================================")
print(results_df.to_markdown(index=False, floatfmt=(".2f", ".4f", ".2f", ".2f")))

print("\n")
print(f"You now have comprehensive evaluation scripts for your LSTM-Only, CNN-Only, and Hybrid CNN-LSTM models. Do you have the script for the final model (CNN-LSTM with Attention, Auxiliary Features, and SHAP) ready for evaluation, or would you like to compare the results of the three models we have so far?")